<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[源代码]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wenhao.github.io//"/>
  <updated>2015-07-08T01:18:40.000Z</updated>
  <id>http://wenhao.github.io//</id>
  
  <author>
    <name><![CDATA[文浩]]></name>
    <email><![CDATA[wenhao@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[小小单例模式]]></title>
    <link href="http://wenhao.github.io/2015/07/07/%E5%B0%8F%E5%B0%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wenhao.github.io/2015/07/07/小小单例模式/</id>
    <published>2015-07-07T13:40:29.000Z</published>
    <updated>2015-07-08T01:18:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong>你熟悉这段代码吗：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> X instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">X</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> X <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">      instance = <span class="keyword">new</span> X();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// more methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>当然。这是GOF这本书里面提到的单例模式。但是我总是听到别人说我们不应该使用它。</em></p>
<p><strong>为什么我们不应该使用它？</strong></p>
<p><em>因为它使得我们的系统难以测试</em></p>
<p><strong>真的吗？为什么会那样呢？</strong></p>
<p><em>因为你不能模拟(mock)一个单例对象。</em></p>
<p><strong>不能吗？为什么不能？</strong></p>
<p><em>这样说吧，因为唯一能够访问私有变量的类只有单例对象自身，不暴露给外部就没办法模拟(mock)。</em></p>
<a id="more"></a>
<p><strong>你知道封装和测试的规则吗？</strong></p>
<p><em>嗯，不知道。规则是什么呢？</em></p>
<p><strong>测试胜过封装。</strong></p>
<p><em>这是什么意思呢？</em></p>
<p><strong>意思就是测试赢了封装。只是为了维持封装性的话，没有测试会被限制访问某个变量。</strong></p>
<p><em>你的意思是如果测试需要访问私有变量…</em></p>
<p><strong>…变量不应该是私有的。对。</strong></p>
<p><em>听起来好像不对。我的意思是，封装，呃，很重要！</em></p>
<p><strong>测试更为重要。</strong></p>
<p><em>等等。什么？</em></p>
<p><strong>如果代码不能够被测试，封装性好的代码又有什么好的呢？</strong></p>
<p><em>好，好吧，但是如果我们不得不测试单例对象呢。</em></p>
<p><strong>看如下代码。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> X instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">X</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> X <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">      instance = <span class="keyword">new</span> X();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// methods.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestX</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X.instance = <span class="keyword">new</span> XMock();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMock</span> <span class="keyword">extends</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overide methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>哦，你把实例变量变成“包”范围。</em></p>
<p><strong>对。</strong></p>
<p><em>这样的话你就可以模拟单例对象了。</em></p>
<p><strong>对。考虑一下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> X instance = <span class="keyword">new</span> X();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">X</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// methods.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>等等！实例方法哪去了？</em></p>
<p><strong>我不需要实例方法。</strong></p>
<p><em>哦，这个实例变量是公共的。你可以直接使用它。</em></p>
<p><strong>对。</strong></p>
<p><em>但是…但是…其他人可能重写它？</em></p>
<p><strong>谁会做那事？</strong></p>
<p><em>我不知道。呃，某些坏人吧。</em></p>
<p><strong>你们团队有这种坏人吗？</strong></p>
<p><em>没有。但是。只是感觉这样做不太安全。</em></p>
<p><strong>这样，如果它是公共API的一部分，我同意你的观点。但是如果这段代码只会被我们项目用到那就另当别论了…</strong></p>
<p><em>我们应该信任我们团队成员？</em></p>
<p><strong>当然。</strong></p>
<p><em>这样更容易模拟(mock)，对吗？</em></p>
<p><strong>当然。</strong></p>
<p><em>如此的话我猜我们应用使用单例模式如果我们想用的话。</em></p>
<p><strong>当然。经管大多数情况下我不想。</strong></p>
<p><em>这一番讨论之后，你现在却想告诉我你不想使用单例模式？</em></p>
<p><strong>是这样，我想理解为什么不适用它更为重要。</strong></p>
<p><em>好吧，为什么你不适用单例模式？</em></p>
<p><strong>我有时候也用。特别是在做公共APIs的时候。</strong></p>
<p><em>你的意思是又是信任的问题？</em></p>
<p><strong>对。在公共API中如果我想确保只有一个实例被创建时，我就会使用单例模式。</strong></p>
<p><em>好吧，但是如果不是在做公共API的时候，但是你任然想只创建一个实例呢？</em></p>
<p><strong>这样的话，我就直接的创建一个。</strong></p>
<hr>
<p>翻译自<a href="http://blog.cleancoder.com/uncle-bob/2015/07/01/TheLittleSingleton.html" target="_blank" rel="external">The Little Singleton</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>你熟悉这段代码吗：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> X instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">X</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> X <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">      instance = <span class="keyword">new</span> X();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// more methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>当然。这是GOF这本书里面提到的单例模式。但是我总是听到别人说我们不应该使用它。</em></p>
<p><strong>为什么我们不应该使用它？</strong></p>
<p><em>因为它使得我们的系统难以测试</em></p>
<p><strong>真的吗？为什么会那样呢？</strong></p>
<p><em>因为你不能模拟(mock)一个单例对象。</em></p>
<p><strong>不能吗？为什么不能？</strong></p>
<p><em>这样说吧，因为唯一能够访问私有变量的类只有单例对象自身，不暴露给外部就没办法模拟(mock)。</em></p>]]>
    
    </summary>
    
      <category term="Robert C. Martin" scheme="http://wenhao.github.io/tags/Robert-C-Martin/"/>
    
      <category term="设计模式" scheme="http://wenhao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wenhao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微服务利弊权衡]]></title>
    <link href="http://wenhao.github.io/2015/07/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%A9%E5%BC%8A%E6%9D%83%E8%A1%A1/"/>
    <id>http://wenhao.github.io/2015/07/06/微服务利弊权衡/</id>
    <published>2015-07-06T04:14:31.000Z</published>
    <updated>2015-07-08T02:23:00.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/microservice.png" alt="微服务架构"></p>
<p>一些开发团队意识到<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">微服务架构风格</a>是解决大型单体架构的首选方案。同时某些团队也发现微服务架构会降低生产效率。与其他架构一样，微服务也具有其利与弊。决定在特定场景之下使用微服务架构之前了解这些还是很有必要的。</p>
<h4 id="微服务的优点…">微服务的优点…</h4><ul>
<li><a href="./微服务利弊权衡.md/#高度的模块边界化">高度的模块边界化</a>：微服务促进系统模块化，特别是针对大型团队。</li>
<li><a href="./微服务利弊权衡.md/#独立部署">独立部署</a>：微服务更容易部署，而且由于微服务大多是独立自主的，当它出错的时候不大可能引起整个系统崩溃。</li>
<li><a href="./微服务利弊权衡.md/#技术架构多样性">技术架构多样性</a>：使用微服务你可以混用多种开发语言，开发框架和数据存储设备。</li>
</ul>
<h4 id="微服务缺点…">微服务缺点…</h4><ul>
<li><a href="./微服务利弊权衡.md/#分布式">分布式</a>：由于远程方法调用低效及出错风险极高，导致分布式系统很难开发。</li>
<li><a href="./微服务利弊权衡.md/#最终一致性">最终一致性</a>：比起开发分布式系统，保持系统之间的高度一致性更加困难，它意味着每个人都必须关注系统的最终一致性。</li>
<li><a href="./微服务利弊权衡.md/#运维复杂性">运维复杂性</a>：微服务经常更新并重新部署，所以你需要一个成熟的团队来管理这些微服务。</li>
</ul>
<a id="more"></a>
<p><a href="./微服务利弊权衡.md/#总结">总结</a></p>
<h3 id="高度的模块边界化">高度的模块边界化</h3><p>第一个优点是微服务使系统高度模块边界化。这是一个很重要的优点但同时也是很奇怪的一个，因为没有任何理由，理论上讲，为什么微服务应用对比大型单体应用要具有高度模块边界化特性。</p>
<p>我所说的高度模块边界化是什么意思呢？我想大部分人会赞同最好把软件分成不同的模块：应用程序之间相互耦合带来的复杂度。当你需要改变你系统的某一个部分使某个功能模块工作时，通常情况下，你只需要理解系统很小的一部分然后更改它，而且你能很容易就找到你需要更改的那一小部分。好的模块化结构在任何程序中都很有用，特别是在软件数量以指数级增长时更为重要。也许更为重要的是，应用程序随着团队开发越大越重要。</p>
<p>微服务的拥护者很快就提出<a href="http://www.thoughtworks.com/insights/blog/demystifying-conways-law" target="_blank" rel="external">Conway法则</a>，软件设计的架构，实际上反应了公司的组织与沟通架构。对于大型团队，特别是分布在不同地区的开发团队。比起大团队，小团队内部的沟通就没必要那么频繁而且更为正式，重新架构软件以适应这种组织结构就变得很重要了。微服务允许各个团队在某种沟通模式下维护自己相对独立的服务单元。</p>
<p>如我之前所说，没有任何理由为什么一个大型单体应用系统不应当具有一个好的模块式的架构。但是大多数人发现这种应用机构很少，因此<a href="https://en.wikipedia.org/wiki/Big_ball_of_mud" target="_blank" rel="external">“大泥球”</a>”任然是普遍使用的架构模型。这种普遍的痛点使得一部分团队转向微服务架构。模块之间解耦之所以可以工作是因为模块的边界减少了模块之间的引用。这样做是一个很有用的策略捷径帮助更快的构建产品功能，但是如果大范围使用却会破坏模块架构和减低团队的生产效率。把几个模块做成分开的服务使得之间的边界更加牢固，但是使它更难寻找痛点。</p>
<p>一种重要的方面是于持久层解耦。去数据中心化是微服务特征之一，它以为者每一个服务负责管理自己的数据库，其他服务必须通过此服务的公共API获取数据而不是直接访问数据库。这就避免了<a href="http://martinfowler.com/bliki/IntegrationDatabase.html" target="_blank" rel="external">数据库集成</a>，它是大型系统中耦合最主要的因数。</p>
<p>值得强调的是在大型单体应用中也可以创建坚固的模块边界，但是需要严格的纪律做支撑。同样微服务也可以开发成“大泥球”，但是它需要更多的工作量在做错误的事。以我之见，使用微服务增加了获取更好模块化架构的可能性。如果你对你们团队的纪律规则有信心，很可能获取那种优势，但是团队不断成长变大之后保持这种纪律规则就愈发困难，维护模块边界就变得更为重要。</p>
<p>如果你创建了错误的边界，这种优势就可能变成一种阻碍。这就是<a href="http://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="external">先开发单体应用</a>策略的两个主要原因之一，也就是为什么那些更倾向于<a href="http://martinfowler.com/articles/dont-start-monolith.html" target="_blank" rel="external">提早做微服务</a>时必须先理解某个领域模型。</p>
<p>然而对于此的警告我还没没有说完。只有在系统维护一段时间之后你才能得出结论这个是否是好的模块化系统。同理，只有在我们使用微服务数年之后，我们才能知道微服务是否是引领更好的系统模块化的解决方案。此外，更早的采用此架构就更加明智，因此，在一般团队开发的微服务之后，收益模块化的优势往往有些延迟。即使那样，我们不得不接受一般团队开发的一般软件，不是与优秀的团队比较结果而是我们不得不与使用单体应用架构开发的软件做比较——这是一种微妙的对照评估。</p>
<p>我将要说的都是别人早期实践过这种架构风格的一些真实问题，他们的判断是越早维护他们的模块越有意义。</p>
<p>有个案例研究特别有趣。某个团队做了错误的选择了使用微服务架构，但是根据文章<a href="http://martinfowler.com/bliki/MicroservicePremium.html" target="_blank" rel="external">微服务代价</a>来说他们的系统还不够复杂。这个项目出现了问题必须挽救，所以大部分人又加入了此项目。这种情况下，微服务架构可以帮上忙，因为比起单体系统来说微服务可以更容易消化大部分开发人员而且可以把大团队平均分配到各个团队。最终，这个团队效率高于开发单体应用，使团队能够追赶进度。但是任然有负面的影响，比起开发单体应用来说，微服务会花费更多的时间开发同样的功能，但是微服务架构在后期也可以提高效率。</p>
<h3 id="分布式">分布式</h3><p>微服务使用分布式系统来提高模块化。但是分布式系统有个很大的缺点，这个缺点正式“分布式的”。一旦你选择了分布式架构，你就会面临太多的复杂性问题。<a href="http://martinfowler.com/articles/distributed-objects-microservices.html" target="_blank" rel="external">我不认为微服务社区会天真的以为分布式对象会带来额外的成本</a>，但是这种复杂度任然存在。</p>
<p>第一个问题是性能。你不得不正视功能之间调用的性能最近成为了热点问题，但是远程调用速度很慢。如果你的服务调用多个远程服务，而且每一个服务又调用其他服务，所有的响应时间加起来会变成可怕的潜在隐患。</p>
<p>当然你可以通过某种方式缓解这个问题。首先你可以增加被调用服务的粒度，你可以只做一些服务。这会使编程模型变得复杂，你不得不考虑批量处理服务之间的调用。这种方法只能达到这种地步，因为一次性你不得不调用所有的关联服务。</p>
<p>第二种缓解方式是使用异步。如果并行调用六个异步方法，你最慢的速度决定于这六个异步调用中最慢的那个而不是六个异步调用时间总和。这种方式可以获得很大的性能改进，但是同时也会导致另外一个我们所知的问题。异步编程很难：难于实现，也难于调试。但是我听说过的大部分微服务案例表明做异步只是为了达到可以接受的性能指标。</p>
<p>性能之后是可靠性。你期待正在执行的功能调用能够工作，但是远程方法调用任何时候都可能失败。如果有大量的微服务的话，失败的几率就更大。聪敏的开发人员早就意识到这一点并及早做<a href="http://martinfowler.com/articles/microservices.html#DesignForFailure" target="_blank" rel="external">故障设计</a>。庆幸的是异步调用的策略也同样可以提高故障处理的弹性。但是这并起不了太大作用，你任然需要做其他的工作来找出具体是哪一个远程调用失败了。</p>
<p>这只是<a href="http://www.infoq.com/cn/news/2009/06/fallacies-distributed-computing" target="_blank" rel="external">分布式计算的谬误</a>提到的前两点。</p>
<p>对于这个问题有一些说明。首先，大部分问题都是随着单体应用不断扩大而导致。某些单体应用都是相对独立的，通常情况下，大部分工作在遗留系统之上。通过网络远程的方式与这些系统交互同样会遇到这些问题。这就是为什么大多数人倾向于更早的使用微服务架构来处理各网络服务之间的信息交付。这种时候经验就很有帮助了，一个有此经验的团队就能更好的解决这些分布式的问题。</p>
<p>但是分布式始终会是个成本问题。每次谈论分布式问题我都有点勉强，因为大多数人在使用分布式机构之前低估了它带来的问题。</p>
<h3 id="最终一致性">最终一致性</h3><p>我确认你也会认同访问网站需要一些耐心。你更新某些东西，如果你重新加载页面，想要更新的数据就丢失了。也许等几分钟之后，再次重新加载页面，更新的内容又出现了。</p>
<p>这种实用性很差的问题令人讨厌，这就是关系到最终一致性问题。你的更新操作可能被粉色节点处理，但是你的请求可能被绿色节点处理。直到绿色节点从粉色节点获取更新的结果，你陷入了不一致的情况。最总内容会达成一致，但是在这个过程中你会好奇是不是什么地方出了问题。</p>
<p>微服务由于具有其去数据中心化的特点，使用它就会造成最终一致性问题。对于单体应用来说，你可以在一个事务期间做多件事。而微服务需要更新多个不同的资源，分布式事务是很讨厌的(合理)。开发人员需要重视一致性问题，为了避免后悔，在做任何编码之间，试图搞清楚如何找出哪些过程是不同步的。</p>
<p>单体应用同样具有这些问题。在系统不断变大后，需要更多的做缓存来提高性能，但是缓存失效又是<a href="http://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="external">另外一个问题</a>。大多数应用程序都需要<a href="http://martinfowler.com/eaaCatalog/optimisticOfflineLock.html" target="_blank" rel="external">离线锁</a>以避免长时间存在的数据库事务。外部系统需要更新但是又不能拥有事务处理。业务流程的不一致性问题没有你想的那么严重，因为业务通常考虑到了这点(业务流程本身就先理解分布式系统<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="external">CAP原理</a>)。</p>
<p>如其他分布式系统问题一样，单体应用也没办法完全避免不一致的问题，但是这种问题要少得多，尤其是单体应用够小的话。</p>
<h3 id="独立部署">独立部署</h3><p>模块边界话和分布式系统的权衡困扰了我整个职业生涯。但是有一件事明显改变，在过去十年里，存在专门负责发布到产品环境的职位。在二十世纪，产品环境发布任然是偶尔而且最痛苦的过程，通常白天黑夜两班倒只是为了把软件放到某个地方可以工作。但是如今，成熟的团队可以频繁的部署的产品环境，许多组织开始实践<a href="http://martinfowler.com/bliki/ContinuousDelivery.html" target="_blank" rel="external">持续交付</a>，使得他们可以一天多次发布到产品环境。</p>
<p>这种改变对整个环境产业具有重大的意义，同样它也深远的影响着微服务。引入微服务就是为了解决部署大型单体应用的复杂度，即便是修改单体应用很小的一部分也可能导致整个部署失败。微服务的一个主要原则就是<a href="http://martinfowler.com/articles/microservices.html#ComponentizationViaServices" target="_blank" rel="external">服务即组件</a>，它们可以独立的部署。也就是说当你修改某个服务时，你只需要测试然后部署这个服务就够了。即便你搞砸了这个服务，也不会使整个系统崩溃。毕竟，由于需要故障设计，即使你的某个组件完全失败掉也不应当使系统的其他部分停止工作。</p>
<p>这是一种双向选择的关系。由于大部分微服务需要频繁的部署，所以你也许要同时兼顾部署。这就是为什么快速应用部署和快速基础设施创建是<a href="http://martinfowler.com/bliki/MicroservicePrerequisites.html" target="_blank" rel="external">微服务的前提</a>。比起这些基础的要求只要，你需要的是做持续交付。</p>
<h3 id="运维复杂性">运维复杂性</h3><h3 id="技术架构多样性">技术架构多样性</h3><h3 id="次要因素">次要因素</h3><h3 id="总结">总结</h3><h4 id="脚注">脚注</h4><h4 id="延伸阅读">延伸阅读</h4><h4 id="鸣谢">鸣谢</h4>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/microservice.png" alt="微服务架构"></p>
<p>一些开发团队意识到<a href="http://martinfowler.com/articles/microservices.html">微服务架构风格</a>是解决大型单体架构的首选方案。同时某些团队也发现微服务架构会降低生产效率。与其他架构一样，微服务也具有其利与弊。决定在特定场景之下使用微服务架构之前了解这些还是很有必要的。</p>
<h4 id="微服务的优点…">微服务的优点…</h4><ul>
<li><a href="./微服务利弊权衡.md/#高度的模块边界化">高度的模块边界化</a>：微服务促进系统模块化，特别是针对大型团队。</li>
<li><a href="./微服务利弊权衡.md/#独立部署">独立部署</a>：微服务更容易部署，而且由于微服务大多是独立自主的，当它出错的时候不大可能引起整个系统崩溃。</li>
<li><a href="./微服务利弊权衡.md/#技术架构多样性">技术架构多样性</a>：使用微服务你可以混用多种开发语言，开发框架和数据存储设备。</li>
</ul>
<h4 id="微服务缺点…">微服务缺点…</h4><ul>
<li><a href="./微服务利弊权衡.md/#分布式">分布式</a>：由于远程方法调用低效及出错风险极高，导致分布式系统很难开发。</li>
<li><a href="./微服务利弊权衡.md/#最终一致性">最终一致性</a>：比起开发分布式系统，保持系统之间的高度一致性更加困难，它意味着每个人都必须关注系统的最终一致性。</li>
<li><a href="./微服务利弊权衡.md/#运维复杂性">运维复杂性</a>：微服务经常更新并重新部署，所以你需要一个成熟的团队来管理这些微服务。</li>
</ul>]]>
    
    </summary>
    
      <category term="Martin Fowler" scheme="http://wenhao.github.io/tags/Martin-Fowler/"/>
    
      <category term="微服务" scheme="http://wenhao.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="翻译" scheme="http://wenhao.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[互联网+]]></title>
    <link href="http://wenhao.github.io/2015/06/09/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    <id>http://wenhao.github.io/2015/06/09/互联网/</id>
    <published>2015-06-09T01:13:41.000Z</published>
    <updated>2015-07-06T04:29:53.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/互联网+.jpg" alt="互联网+"></p>
<p>&emsp;&emsp;眼下，互联网+持续升温，发展迅猛，加之政府大力扶持，中国经济开始进入技术、模式和产业大变革时期。在“站在这个风口上，猪都能飞起来了”的大背景之下，涌现出了一大批勇于创业积极创新的先进集体和个人。</p>
<h3 id="宏观政策">宏观政策</h3><p>&emsp;&emsp;当下，经济下行压力巨大，消费、投资和出口已不再是保持中国经济增长可靠的引擎。中国迫切的需要一个新的政策来拉动经济，促进消费及解决日益严峻的就业压力；加之地产行业的持续低迷，资产加速逃离，大量闲置资金急迫需要寻找下一个可靠的“资金池”以缓解经济运行压力。 “大众创业、万众创新”作为经济增长的双引擎之首写入政府工作报告， 以一种”抛开杂念，放手一搏“的精神激励着广大人民勇于创业积极创新的势头，可见政府抓重点调整产业结构的决心。互联网+恰好在各行各业起到了催化剂的作用，必将加速重塑传统行业的进程。</p>
<a id="more"></a>
<h3 id="趋势">趋势</h3><ul>
<li>连接需求方和供给方，去中心化。带来的是提高效率并充分利用资源，减少中间的分销流程，提供更为个性化的服务。例子：Uber、途家等。</li>
<li>传统行业互联网化，众多的细分行业都可以通过互联网获得发展机会。例如：B2C、C2C等。</li>
<li>对接互联网金融，一切的产业都需要金融的支持。例如：支付宝、陆金所P2P等。</li>
<li>智能时代，各种智能设备必将掀起新一轮的产业革命。例如：智能电视、智能家居、智能汽车、医疗健康、智能玩具、机器人等领域。</li>
</ul>
<h3 id="实践">实践</h3><h5 id="互联网+政府服务：">互联网+政府服务：</h5><p>&emsp;&emsp;资源整合，从基础设施服务(驾照违法查询、车辆年检预约、结婚登记预约、全程路况、水、电、煤气等)入手，对接政府各机构数据，打造一体化的城市服务平台。在不久的将来，也许不会再有类似“抄电表”之类的“土豪”工作，但是同样也会间接地衍生出很多需要特定专业技能的就业机会。</p>
<h5 id="互联网+传统农业：">互联网+传统农业：</h5><p>&emsp;&emsp;提高农村土地使用率，促进现代化农业进程，减少中间环节，细分市场，精准营销。例如：天天果园。</p>
<h5 id="互联网+教育：">互联网+教育：</h5><p>&emsp;&emsp;在线教育已不是什么新鲜的名词，而针对教育产业的“细分市场”提供更为”个性化“的授课体验也许会成为另一个朝阳产业。例如作业帮和学霸君等。</p>
<h5 id="互联网+医疗：">互联网+医疗：</h5><p>&emsp;&emsp;以往由于信息不对称导致药品价格虚高的现象将不复存在，药品电商会逐步取代传统的药品销售模式。各种可穿戴设备可以进一步提升医疗效率，避免医疗资源浪费。也许”医药代表“这一类”高大上“职业会慢慢退出历史的舞台。</p>
<p>更多……</p>
<h3 id="事件">事件</h3><ul>
<li>2014年8月29日，经国务院同意，发改委、工信部、科技部、公安部、财政部、国土部、住建部、交通部等八部委印发《关于促进智慧城市健康发展的指导意见》，要求各地区、各有关部门落实本指导意见提出的各项任务，确保智慧城市建设健康有序推进。</li>
<li>2014年9月10日，李克强提出，要在960万平方公里土地上掀起“大众创业”“草根创业”的新浪潮，形成“万众创新”“人人创新”的新态势。</li>
<li>2015年3月5日，在十二届全国人大三次会议上，李克强总理在政府工作报告中首次提出“互联网＋”行动计划。</li>
<li>2015年4月22日，蚂蚁金融服务集团、阿里巴巴集团与新浪微博，共同启动“互联网+城市服务”战略，联合为各地政府提供“智慧城市”的一站式解决方案。</li>
<li>2015年5月18日，暴风科技完成了第36个涨停，股价收报于248.6元，总市值达到298.32亿元，这接近迅雷市值（7.29亿美元）的6倍和优酷土豆38亿美元的市值。</li>
<li>2015年5月25日，四川省人民政府与腾讯公司在成都签署战略合作协议，就“互联网+”达成全面深层合作。</li>
</ul>
<h3 id="最后">最后</h3><p>&emsp;&emsp;以”互联网+痛点“为出发点可以衍生出很多新的创业创新的机会。产业和模式的创新需要依托技术的创新及支持，作为具备“创新”基因的TWers若能给站在“风口”上的创业者们提供专业的软件服务何尝不是另一种新的“互联网+软件服务”的革命呢?</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/互联网+.jpg" alt="互联网+"></p>
<p>&emsp;&emsp;眼下，互联网+持续升温，发展迅猛，加之政府大力扶持，中国经济开始进入技术、模式和产业大变革时期。在“站在这个风口上，猪都能飞起来了”的大背景之下，涌现出了一大批勇于创业积极创新的先进集体和个人。</p>
<h3 id="宏观政策">宏观政策</h3><p>&emsp;&emsp;当下，经济下行压力巨大，消费、投资和出口已不再是保持中国经济增长可靠的引擎。中国迫切的需要一个新的政策来拉动经济，促进消费及解决日益严峻的就业压力；加之地产行业的持续低迷，资产加速逃离，大量闲置资金急迫需要寻找下一个可靠的“资金池”以缓解经济运行压力。 “大众创业、万众创新”作为经济增长的双引擎之首写入政府工作报告， 以一种”抛开杂念，放手一搏“的精神激励着广大人民勇于创业积极创新的势头，可见政府抓重点调整产业结构的决心。互联网+恰好在各行各业起到了催化剂的作用，必将加速重塑传统行业的进程。</p>]]>
    
    </summary>
    
      <category term="互联网+" scheme="http://wenhao.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="互联网+" scheme="http://wenhao.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
</feed>